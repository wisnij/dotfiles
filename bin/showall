#!/usr/bin/perl

use strict;
use warnings;

use Encode qw(decode);
use Term::ANSIColor;
use Getopt::Long qw(:config gnu_getopt);


my $usage = <<"EOF;";
Usage: $0 [OPTION]... [FILE]...
  -e  show line ends with \$
  -c  show nonprinting characters as ^ escapes (e.g. ^M == \\r)
  -t  show tabs
  -a  -e and -t
EOF;

my ($char_escapes, $line_ends, $encoding, $show_tabs);
my $show_color = 1;
GetOptions(
    'a|all!'          => sub { $_ = $_[1] for $line_ends, $show_tabs },
    'c|char-escapes!' => \$char_escapes,
    'e|line-ends!'    => \$line_ends,
    'E|encoding=s'    => \$encoding,
    't|show-tabs!'    => \$show_tabs,
    'u|unicode'      => sub { $encoding = 'UTF-8' },
    'colors!'         => \$show_color,
    'help|h|?'        => sub { print $usage; exit },
) or die "error parsing options\n";

sub hl
{
    my ($str) = @_;
    return $str if not $show_color;
    return colored( $str, 'cyan' );
}

sub esc_char
{
    my ($char) = @_;
    return hl '\e' if $char eq "\e";
    return hl '\r' if $char eq "\r";
    return ($show_tabs ? hl '\t' : $char) if $char eq "\t";

    my $ord = ord $char;
    my $format = ($ord > 0xff) ? 'U+%04X' : '%02X';
    return hl sprintf "<$format>", $ord;
}


$| = 1;
while( defined( my $line = <> ) )
{
    $line = decode($encoding, $line)
        if $encoding;

    # nonprinting control characters (except newline)
    if( $char_escapes )
    {
        $line =~ s/([\x00-\x09\x0B-\x1F])/hl   '<^' . chr( ord($1)       + 64 ) . '>' /eg;
        $line =~ s/([\x80-\x9F])/         hl '<M-^' . chr( ord($1) - 128 + 64 ) . '>' /eg;
        $line =~ s/([\xA0-\xFE])/         hl '<M-'  . chr( ord($1) - 128 )      . '>' /eg;

        # special cases
        $line =~ s/\x7F/hl '<^?>'/eg;
        $line =~ s/\xFF/hl '<M-^?>'/eg;
    }
    else
    {
        $line =~ s/([^\x0A\x20-\x7E])/esc_char( $1 )/eg;
    }

    # mark line ends
    $line =~ s/$/hl '$'/e if $line_ends;

    print $line;
}
